//
// Generated by JTB 1.3.2
//

package visitor;
import syntaxtree.*;
import java.util.*;

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */
public class GJDepthFirst<R,A> implements GJVisitor<R,A> {
   //
   // Auto class visitors--probably don't need to be overridden.
  
	 public R visit(NodeList n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeListOptional n, A argu) {
      if ( n.present() ) {
         R _ret=null;
         int _count=0;
         for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
            e.nextElement().accept(this,argu);
            _count++;
         }
         return _ret;
      }
      else
         return null;
   }

   public R visit(NodeOptional n, A argu) {
      if ( n.present() )
         return n.node.accept(this,argu);
      else
         return null;
   }

   public R visit(NodeSequence n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeToken n, A argu) { return (R)n.tokenImage; }

   //
   // User-generated visitor methods below
   //

   public HashMap<String, ClassData> classMap = new HashMap<String, ClassData>();
   public boolean build = true;
   public boolean debug = true;
   public int tempNumber = 0;
   public int getNextTemp()
   {
      return tempNumber++;
   }
   public int labelNumber = 0;
   public int getNextLabel()
   {
      return labelNumber++;
   }

   public int createObject(int temp, String className)
   {
      ClassData classData = classMap.get(className);
      int methodTableSize = classData.getMethodTableSize();
      int methodTableTemp = getNextTemp();
      System.out.println("MOVE TEMP " + methodTableTemp + " HALLOCATE " + methodTableSize);
      
      for(int i = 0; i<classData.methodList.size(); i++)
      {
         MethodData methodData = classData.methodDataMap.get(classData.methodList.get(i));
         String label = className + "_" + methodData.methodName;
         int labelTemp = getNextTemp();
         System.out.println("MOVE TEMP " + labelTemp + " " + label);
         System.out.println("HSTORE TEMP " + methodTableTemp + " " + i*4 + " TEMP " + labelTemp);
      }

      int classTableSize = classData.getVariableTableSize();
      classTableSize += 4;
      int classTableTemp = getNextTemp();
      System.out.println("MOVE TEMP " + classTableTemp + " HALLOCATE " + classTableSize);
      System.out.println("HSTORE TEMP " + classTableTemp + " 0 TEMP " + methodTableTemp);

      if(classData.parentName != null) 
      {
         int parentTemp = getNextTemp();
         System.out.println("\nALLOCATE Parent Class " + classData.parentName + "\n");
         parentTemp = createObject(parentTemp, classData.parentName);
         System.out.println("HSTORE TEMP " + classTableTemp + " 4 TEMP " + parentTemp);
      }
      System.out.println("MOVE TEMP " + temp + " TEMP " + classTableTemp);

      return temp;
   }

   public int findIdentifierValue(int temp, String id, CMI cmi)
   {
      String className = cmi.className;
      String methodName = cmi.methodName;
      ClassData classData = classMap.get(className);
      MethodData methodData = classData.methodDataMap.get(methodName);

      if(methodData.variableOffset.containsKey(id))
      {
         int offset = methodData.variableOffset.get(id);
         System.out.println("MOVE TEMP " + temp + " TEMP " + offset);
      }
      else if(methodData.parameterOffset.containsKey(id))
      {
         int offset = methodData.parameterOffset.get(id);
         System.out.println("MOVE TEMP " + temp + " TEMP " + offset);
      }
      else if(classData.variableOffset.containsKey(id))
      {
         int offset = classData.variableOffset.get(id);
         System.out.println("HLOAD TEMP " + temp + " TEMP 0 " + offset);
      }
      else
      {
         System.out.println("ERROR: Identifier " + id + " not found");
      }      
      return temp;
   }

   /**
    * f0 -> MainClass()
    * f1 -> ( TypeDeclaration() )*
    * f2 -> <EOF>
    */
   public R visit(Goal n, A argu) {
		/* YOUR CODE HERE */

      R _ret=null;
      
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);

      for(String key : classMap.keySet()) {
         ClassData classData = classMap.get(key);
         classData.printClassData();
      }

      build = false;

      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "{"
    * f3 -> "public"
    * f4 -> "static"
    * f5 -> "void"
    * f6 -> "main"
    * f7 -> "("
    * f8 -> "String"
    * f9 -> "["
    * f10 -> "]"
    * f11 -> Identifier()
    * f12 -> ")"
    * f13 -> "{"
    * f14 -> PrintStatement()
    * f15 -> "}"
    * f16 -> "}"
    */
   public R visit(MainClass n, A argu) 
   {
      String className = n.f1.accept(this, argu).toString();
      String methodName = n.f6.accept(this, argu).toString();

      ClassData classData = new ClassData(className, null);
      MethodData methodData = new MethodData(methodName, "void");
      classData.addMethod(methodName, methodData);

      if(!build) n.f14.accept(this, argu);

      return null;
   }

   /**
    * f0 -> ClassDeclaration()
    *       | ClassExtendsDeclaration()
    */
   public R visit(TypeDeclaration n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "{"
    * f3 -> ( VarDeclaration() )*
    * f4 -> ( MethodDeclaration() )*
    * f5 -> "}"
    */
   public R visit(ClassDeclaration n, A argu) 
   {
      String className = n.f1.accept(this, argu).toString();

      ClassData classData = new ClassData(className, null);
      classMap.put(className, classData);

      CMI cmi = new CMI();
      cmi.className = className;
      cmi.methodName = null;
      cmi.com = 0;

      argu = (A)cmi;

      if(build) n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      return null;
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "extends"
    * f3 -> Identifier()
    * f4 -> "{"
    * f5 -> ( VarDeclaration() )*
    * f6 -> ( MethodDeclaration() )*
    * f7 -> "}"
    */
   public R visit(ClassExtendsDeclaration n, A argu) 
   {
      String className = n.f1.accept(this, argu).toString();
      String parentName = n.f3.accept(this, argu).toString();

      ClassData classData = new ClassData(className, parentName);
      classMap.put(className, classData);

      CMI cmi = new CMI();
      cmi.className = className;
      cmi.methodName = null;
      cmi.com = 0;

      argu = (A)cmi;
      if(build) n.f5.accept(this, argu);
      n.f6.accept(this, argu);
      return null;
   }

   /**
    * f0 -> Type()
    * f1 -> Identifier()
    * f2 -> ";"
    */
   public R visit(VarDeclaration n, A argu) 
   {
      String type = n.f0.accept(this, argu).toString();
      String varName = n.f1.accept(this, argu).toString();

      CMI cmi = (CMI)argu;
      if(cmi.com == 0)
      {
         ClassData classData = classMap.get(cmi.className);
         classData.addVariable(varName);
      }
      else
      {
         ClassData classData = classMap.get(cmi.className);
         MethodData methodData = classData.methodDataMap.get(cmi.methodName);
         methodData.addVariable(varName);
      }
      return null;
   }

   /**
    * f0 -> "public"
    * f1 -> Type()
    * f2 -> Identifier()
    * f3 -> "("
    * f4 -> ( FormalParameterList() )?
    * f5 -> ")"
    * f6 -> "{"
    * f7 -> ( VarDeclaration() )*
    * f8 -> ( Statement() )*
    * f9 -> "return"
    * f10 -> Expression()
    * f11 -> ";"
    * f12 -> "}"
    */
   public R visit(MethodDeclaration n, A argu) 
   {
      String returnType = n.f1.accept(this, argu).toString();
      String methodName = n.f2.accept(this, argu).toString();

      CMI cmi = (CMI)argu;
      ClassData classData = classMap.get(cmi.className);
      MethodData methodData = new MethodData(methodName, returnType);
      classData.addMethod(methodName, methodData);

      cmi.methodName = methodName;
      cmi.com = 1;

      if(build) n.f4.accept(this, argu);
      if(build) n.f7.accept(this, argu);

      tempNumber = methodData.parameterCount + 1 + methodData.variableCount;

      if(!build) n.f8.accept(this, argu);

      n.f10.accept(this, argu);

      tempNumber = 0;
      labelNumber = 0;
      return null;
   }

   /**
    * f0 -> FormalParameter()
    * f1 -> ( FormalParameterRest() )*
    */
   public R visit(FormalParameterList n, A argu) {
		/* YOUR CODE HERE */

      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Type()
    * f1 -> Identifier()
    */
   public R visit(FormalParameter n, A argu) 
   {
      String type = n.f0.accept(this, argu).toString();
      String parName = n.f1.accept(this, argu).toString();
      CMI cmi = (CMI)argu;
      ClassData classData = classMap.get(cmi.className);
      MethodData methodData = classData.methodDataMap.get(cmi.methodName);
      methodData.addParameter(parName);
      return null;
   }

   /**
    * f0 -> ","
    * f1 -> FormalParameter()
    */
   public R visit(FormalParameterRest n, A argu) {
		/* YOUR CODE HERE */

      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> ArrayType()
    *       | BooleanType()
    *       | IntegerType()
    *       | Identifier()
    */
   public R visit(Type n, A argu) 
   {
      R _ret = n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "int"
    * f1 -> "["
    * f2 -> "]"
    */
   public R visit(ArrayType n, A argu) 
   {
      R _ret = (R)"int[]";
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "boolean"
    */
   public R visit(BooleanType n, A argu) 
   {
      R _ret = (R)"boolean";
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "int"
    */
   public R visit(IntegerType n, A argu) 
   {
      R _ret = (R)"int";
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Block()
    *       | AssignmentStatement()
    *       | ArrayAssignmentStatement()
    *       | IfStatement()
    *       | WhileStatement()
    *       | PrintStatement()
    */
   public R visit(Statement n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "{"
    * f1 -> ( Statement() )*
    * f2 -> "}"
    */
   public R visit(Block n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Identifier()
    * f1 -> "="
    * f2 -> Expression()
    * f3 -> ";"
    */
   public R visit(AssignmentStatement n, A argu) {
		/* YOUR CODE HERE */

      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Identifier()
    * f1 -> "["
    * f2 -> Expression()
    * f3 -> "]"
    * f4 -> "="
    * f5 -> Expression()
    * f6 -> ";"
    */
   public R visit(ArrayAssignmentStatement n, A argu) {
		/* YOUR CODE HERE */

      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      n.f5.accept(this, argu);
      n.f6.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> IfthenElseStatement()
    *       | IfthenStatement()
    */
   public R visit(IfStatement n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "if"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> Statement()
    */
   public R visit(IfthenStatement n, A argu) {
		/* YOUR CODE HERE */

      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "if"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> Statement()
    * f5 -> "else"
    * f6 -> Statement()
    */
   public R visit(IfthenElseStatement n, A argu) 
   {
      if(debug) System.out.println("\nIfthenElseStatement\n");
   }

   /**
    * f0 -> "while"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> Statement()
    */
   public R visit(WhileStatement n, A argu) 
   {
      if(debug) System.out.println("\nWhileStatement\n");

		int label = getNextLabel();
      int jumpLabel = getNextLabel();
      System.out.println("L" + label);
      int exprTemp = Integer.parseInt(n.f2.accept(this, argu).toString());
      System.out.println("CJUMP TEMP " + exprTemp + "L" + jumpLabel);
      n.f4.accept(this, argu);
      System.out.println("JUMP L" + label);
      return null;
   }

   /**
    * f0 -> "System.out.println"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> ";"
    */
   public R visit(PrintStatement n, A argu) 
   {
      int exprTemp = Integer.parseInt(n.f2.accept(this, argu).toString());
      System.out.println("PRINT TEMP " + exprTemp);
      return null;
   }

   /**
    * f0 -> OrExpression()
    *       | AndExpression()
    *       | CompareExpression()
    *       | neqExpression()
    *       | PlusExpression()
    *       | MinusExpression()
    *       | TimesExpression()
    *       | DivExpression()
    *       | ArrayLookup()
    *       | ArrayLength()
    *       | MessageSend()
    *       | PrimaryExpression()
    */
   public R visit(Expression n, A argu) 
   {
      R _ret = n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "&&"
    * f2 -> PrimaryExpression()
    */
   public R visit(AndExpression n, A argu) 
   {
      if(debug) System.out.println("\nAndExpression\n");

      int tempValue1 = Integer.parseInt(n.f0.accept(this, argu).toString());
      int tempValue2 = Integer.parseInt(n.f2.accept(this, argu).toString());
      int newTemp = getNextTemp();
      
      //Not done yet

      return (R)Integer.toString(newTemp);
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "||"
    * f2 -> PrimaryExpression()
    */
   public R visit(OrExpression n, A argu) 
   {
      if(debug) System.out.println("\nOrExpression\n");

      int tempValue1 = Integer.parseInt(n.f0.accept(this, argu).toString());
      int tempValue2 = Integer.parseInt(n.f2.accept(this, argu).toString());
      int newTemp = getNextTemp();
      
      //Not done yet

      return (R)Integer.toString(newTemp);
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "<="
    * f2 -> PrimaryExpression()
    */
   public R visit(CompareExpression n, A argu) 
   {
      if(debug) System.out.println("\nLessOrEqualExpression\n");

      int tempValue1 = Integer.parseInt(n.f0.accept(this, argu).toString());
      int tempValue2 = Integer.parseInt(n.f2.accept(this, argu).toString());
      int newTemp = getNextTemp();
      System.out.println("MOVE TEMP " + newTemp + " LE TEMP " + tempValue1 + " TEMP " + tempValue2);
      return (R)Integer.toString(newTemp);
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "!="
    * f2 -> PrimaryExpression()
    */
   public R visit(neqExpression n, A argu) 
   {
      if(debug) System.out.println("\nNotEqualExpression\n");

      int tempValue1 = Integer.parseInt(n.f0.accept(this, argu).toString());
      int tempValue2 = Integer.parseInt(n.f2.accept(this, argu).toString());
      int newTemp = getNextTemp();
      System.out.println("MOVE TEMP " + newTemp + " NE TEMP " + tempValue1 + " TEMP " + tempValue2);
      return (R)Integer.toString(newTemp);
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "+"
    * f2 -> PrimaryExpression()
    */
   public R visit(PlusExpression n, A argu) 
   {
      if(debug) System.out.println("\nPlusExpression\n");

      int tempValue1 = Integer.parseInt(n.f0.accept(this, argu).toString());
      int tempValue2 = Integer.parseInt(n.f2.accept(this, argu).toString());
      int newTemp = getNextTemp();
      System.out.println("MOVE TEMP " + newTemp + " PLUS TEMP " + tempValue1 + " TEMP " + tempValue2);
      return (R)Integer.toString(newTemp);
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "-"
    * f2 -> PrimaryExpression()
    */
   public R visit(MinusExpression n, A argu) 
   {
		if(debug) System.out.println("\nMinusExpression\n");

      int tempValue1 = Integer.parseInt(n.f0.accept(this, argu).toString());
      int tempValue2 = Integer.parseInt(n.f2.accept(this, argu).toString());
      int newTemp = getNextTemp();
      System.out.println("MOVE TEMP " + newTemp + " MINUS TEMP " + tempValue1 + " TEMP " + tempValue2);
      return (R)Integer.toString(newTemp);
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "*"
    * f2 -> PrimaryExpression()
    */
   public R visit(TimesExpression n, A argu) 
   {
      if(debug) System.out.println("\nTimesExpression\n");

      int tempValue1 = Integer.parseInt(n.f0.accept(this, argu).toString());
      int tempValue2 = Integer.parseInt(n.f2.accept(this, argu).toString());
      int newTemp = getNextTemp();
      System.out.println("MOVE TEMP " + newTemp + " TIMES TEMP " + tempValue1 + " TEMP " + tempValue2);
      return (R)Integer.toString(newTemp);
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "/"
    * f2 -> PrimaryExpression()
    */
   public R visit(DivExpression n, A argu) 
   {
      if(debug) System.out.println("\nDivExpression\n");

      int tempValue1 = Integer.parseInt(n.f0.accept(this, argu).toString());
      int tempValue2 = Integer.parseInt(n.f2.accept(this, argu).toString());
      int newTemp = getNextTemp();
      System.out.println("MOVE TEMP " + newTemp + " DIV TEMP " + tempValue1 + " TEMP " + tempValue2);
      return (R)Integer.toString(newTemp);
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "["
    * f2 -> PrimaryExpression()
    * f3 -> "]"
    */
   public R visit(ArrayLookup n, A argu) 
   {
      if(debug) System.out.println("\nArrayLookup\n");

      int arrayAddrTemp = Integer.parseInt(n.f1.accept(this, argu).toString());
      int accessPoint = Integer.parseInt(n.f2.accept(this, argu).toString());
      int newTemp = getNextTemp();
      accessPoint += 1;
      accessPoint *= 4;
      System.out.println("HLOAD TEMP " + newTemp + " TEMP " + arrayAddrTemp + " " + accessPoint);
      return (R)Integer.toString(newTemp);
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "."
    * f2 -> "length"
    */
   public R visit(ArrayLength n, A argu) 
   {
      if(debug) System.out.println("\nArrayLength\n");

      int tempValue = Integer.parseInt(n.f0.accept(this, argu).toString());
      int newTemp = getNextTemp();
      System.out.println("HLOAD TEMP " + newTemp + " TEMP " + tempValue + " 0");
      return (R)Integer.toString(newTemp);
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "."
    * f2 -> Identifier()
    * f3 -> "("
    * f4 -> ( ExpressionList() )?
    * f5 -> ")"
    */
   public R visit(MessageSend n, A argu) {
		/* YOUR CODE HERE */

      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      n.f5.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Expression()
    * f1 -> ( ExpressionRest() )*
    */
   public R visit(ExpressionList n, A argu) {
		/* YOUR CODE HERE */

      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> ","
    * f1 -> Expression()
    */
   public R visit(ExpressionRest n, A argu) {
		/* YOUR CODE HERE */

      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> IntegerLiteral()                 //value in some temp
    *       | TrueLiteral()                  // 1 in some temp
    *       | FalseLiteral()                 // 0 in some temp
    *       | Identifier()
    *       | ThisExpression()               // 0
    *       | ArrayAllocationExpression()    // temp value of newly-created array of (size + 1) elements array[0] = size
    *       | AllocationExpression()         // temp value of newly-created object
    *       | NotExpression()                // 1 - value of expression in a temp
    *       | BracketExpression()            // value of expression in a temp
    */
   public R visit(PrimaryExpression n, A argu) 
   {
      R _ret = n.f0.accept(this, argu);
      PERN pern = (PERN)_ret;

      if(pern.tempOrIdentifier == 0) _ret = (R)Integer.toString(pern.tempValue);
      else
      {
         int newTemp = getNextTemp();
         newTemp = findIdentifierValue(newTemp, pern.identifier, (CMI)argu);
         _ret = (R)Integer.toString(newTemp);
      }
      return _ret;
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   public R visit(IntegerLiteral n, A argu)
   {
      if(debug) System.out.println("\nIntegerLiteral\n");

      R _ret = n.f0.accept(this, argu);
      String value = _ret.toString();
      int intTemp = getNextTemp();
      System.out.println("MOVE TEMP " + intTemp + " " + value);
      PERN pern = new PERN();
      pern.tempValue = intTemp;
      pern.tempOrIdentifier = 0;
      return (R)pern;
   }

   /**
    * f0 -> "true"
    */
   public R visit(TrueLiteral n, A argu) 
   {
      if(debug) System.out.println("\nTrueLiteral\n");

      int trueTemp = getNextTemp();
      System.out.println("MOVE TEMP " + trueTemp + " 1");
      PERN pern = new PERN();
      pern.tempValue = trueTemp;
      pern.tempOrIdentifier = 0;
      return (R)pern;
   }

   /**
    * f0 -> "false"
    */
   public R visit(FalseLiteral n, A argu) 
   {
      if(debug) System.out.println("\nFalseLiteral\n");

      int falseTemp = getNextTemp();
      System.out.println("MOVE TEMP " + falseTemp + " 0");
      PERN pern = new PERN();
      pern.tempValue = falseTemp;
      pern.tempOrIdentifier = 0;
      return (R)pern;
   }

   /**
    * f0 -> <IDENTIFIER>
    */
   public R visit(Identifier n, A argu) 
   {
      R _ret = null;
      _ret = n.f0.accept(this, argu);
      PERN pern = new PERN();
      pern.identifier = _ret.toString();
      pern.tempOrIdentifier = 1;
      return (R)pern;
   }

   /**
    * f0 -> "this"
    */
   public R visit(ThisExpression n, A argu) 
   {
      PERN pern = new PERN();
      pern.tempValue = 0;
      pern.tempOrIdentifier = 0;
      return (R)pern;
   }

   /**
    * f0 -> "new"
    * f1 -> "int"
    * f2 -> "["
    * f3 -> Expression()
    * f4 -> "]"
    */
   public R visit(ArrayAllocationExpression n, A argu) 
   {
      if(debug) System.out.println("\nArrayAllocationExpression\n");

      int oneTemp = getNextTemp();
      System.out.println("MOVE TEMP " + oneTemp + " 1");
      int exprTemp = Integer.parseInt(n.f3.accept(this, argu).toString());
      int sizeTempSimple = getNextTemp();
      System.out.println("MOVE TEMP " + sizeTempSimple + " PLUS TEMP " + exprTemp + " TEMP " + oneTemp);
      int sizeTempExact = getNextTemp();
      System.out.println("MOVE TEMP " + sizeTempExact + " TIMES TEMP " + sizeTempSimple + " 4");
      int addrTemp = getNextTemp();
      System.out.println("MOVE TEMP " + addrTemp + " HALLOCATE TEMP " + sizeTempExact);
      System.out.println("HSTORE TEMP " + addrTemp + " 0 TEMP " + exprTemp);
      int finalTemp = getNextTemp();
      System.out.println("MOVE TEMP " + finalTemp + " TEMP " + addrTemp);

      PERN pern = new PERN();
      pern.tempValue = finalTemp;
      pern.tempOrIdentifier = 0;
      return (R)pern;
   }

   /**
    * f0 -> "new"
    * f1 -> Identifier()
    * f2 -> "("
    * f3 -> ")"
    */
   public R visit(AllocationExpression n, A argu) 
   {
      String className = n.f1.accept(this, argu).toString();
      int objTemp = getNextTemp();
      if(debug) System.out.println("\nALLOCATE " + className + "\n");
      objTemp = createObject(objTemp, className);
      
      PERN pern = new PERN();
      pern.tempValue = objTemp;
      pern.tempOrIdentifier = 0;
      return (R)pern;
   }

   /**
    * f0 -> "!"
    * f1 -> Expression()
    */
   public R visit(NotExpression n, A argu) 
   {
      if(debug) System.out.println("\nNotExpression\n");

      int oneTemp = getNextTemp();
      System.out.println("MOVE TEMP " + oneTemp + " 1");
      int temp1 = getNextTemp();
      int exprTemp = Integer.parseInt(n.f1.accept(this, argu).toString());
      System.out.println("MOVE TEMP " + temp1 + " MINUS " + " TEMP " + oneTemp + " TEMP " + exprTemp);
      
      PERN pern = new PERN();
      pern.tempValue = temp1;
      pern.tempOrIdentifier = 0;
      return (R)pern;
   }

   /**
    * f0 -> "("
    * f1 -> Expression()
    * f2 -> ")"
    */
   public R visit(BracketExpression n, A argu) 
   {
      R _ret = n.f1.accept(this, argu);
      PERN pern = new PERN();
      pern.tempValue = Integer.parseInt(_ret.toString());
      pern.tempOrIdentifier = 0;
      return (R)pern;
   }

      /**
    * f0 -> Identifier()
    * f1 -> ( IdentifierRest() )*
    */
    public R visit(IdentifierList n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> ","
    * f1 -> Identifier()
    */
   public R visit(IdentifierRest n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      return _ret;
   }
}

class ClassData
{
   public String className;
   public String parentName;
   public int variableCount;
   public int methodCount;
   public HashMap<String, Integer> variableOffset;
   public HashMap<String, Integer> methodOffset;
   public HashMap<String, MethodData> methodDataMap;
   public ArrayList<String> methodList;
   public int varOffset;
   public int metOffset;

   public ClassData(String className, String parentName)
   {
      this.className = className;
      this.parentName = parentName;
      variableCount = 0;
      methodCount = 0;
      variableOffset = new HashMap<String, Integer>();
      methodOffset = new HashMap<String, Integer>();
      methodDataMap = new HashMap<String, MethodData>();
      methodList = new ArrayList<String>();
      varOffset = 4;
      metOffset = 0;
   }

   public void addVariable(String variableName)
   {
      variableOffset.put(variableName, varOffset);
      varOffset += 4;
      variableCount++;
   }

   public void addMethod(String methodName, MethodData methodData)
   {
      methodOffset.put(methodName, metOffset);
      methodDataMap.put(methodName, methodData);
      methodList.add(methodName);
      metOffset += 4;
      methodCount++;
   }

   public int getMethodTableSize() 
   {
      return 4*methodCount;
   }

   public int getVariableTableSize() 
   {
      return 4*(variableCount + 1);
   }

   public void printClassData()
   {
      System.out.println("Class Name: " + className);
      System.out.println("Parent Name: " + parentName);
      System.out.println("Class " + className + " Variable Count: " + variableCount);
      System.out.println("Variable Offset: " + variableOffset);
      System.out.println("Class " + className + " Method Count: " + methodCount);
      System.out.println("Method Offset: " + methodOffset);
      for(String methodName : methodDataMap.keySet())
      {
         System.out.println("Method Name: " + methodName);
         methodDataMap.get(methodName).printMethodData();
      }
      System.out.println("Class " + className + " Variable Table Size: " + getVariableTableSize());
      System.out.println("Class " + className + " Method Table Size: " + getMethodTableSize());
   }
}

class MethodData
{
   public String methodName;
   public String returnType;
   public int variableCount;
   public int parameterCount;
   public HashMap<String, Integer> variableOffset;  // This gives the TEMP value directly for the variables
   public HashMap<String, Integer> parameterOffset; // This gives the TEMP value directly for the parameters
   public int varOffset; 
   public int parOffset;

   public MethodData(String methodName, String returnType)
   {
      this.methodName = methodName;
      this.returnType = returnType;
      variableCount = 0;
      parameterCount = 0;
      variableOffset = new HashMap<String, Integer>();
      parameterOffset = new HashMap<String, Integer>();
      parOffset = 1;
      varOffset = 1;
   }

   public void addParameter(String parameterName)
   {
      parameterOffset.put(parameterName, parOffset);
      parOffset++;
      varOffset = parOffset;
      parameterCount++;
   }

   public void addVariable(String variableName)
   {
      variableOffset.put(variableName, varOffset);
      varOffset += 1;
      variableCount++;
   }

   public int getVarTempValue(String variableName)
   {
      if(variableOffset.containsKey(variableName))
         return variableOffset.get(variableName);
      else if(parameterOffset.containsKey(variableName))
         return parameterOffset.get(variableName);
      else
         return -1; //this tells us to check in class variables and parent class variables
   }

   public void printMethodData()
   {
      System.out.println("Method "+ methodName + " Parameter Count: " + parameterCount);
      System.out.println("Parameters: " + parameterOffset);
      System.out.println("Method "+ methodName + " Variable Count: " + variableCount);
      System.out.println("Variables: " + variableOffset);
   }
}

class CMI
{
   public String className;
   public String methodName;
   public int com;
}

class PERN{
   int tempValue;
   String identifier;
   int tempOrIdentifier;
}
