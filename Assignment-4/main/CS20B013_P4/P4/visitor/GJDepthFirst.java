//
// Generated by JTB 1.3.2
//

package visitor;
import syntaxtree.*;
import java.util.*;

//import jdk.nashorn.internal.codegen.SpillObjectCreator;

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */
public class GJDepthFirst<R,A> implements GJVisitor<R,A> {
   //
   // Auto class visitors--probably don't need to be overridden.
   //
   public R visit(NodeList n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeListOptional n, A argu) {
      if ( n.present() ) {
         R _ret=null;
         int _count=0;
         for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
            e.nextElement().accept(this,argu);
            _count++;
         }
         return _ret;
      }
      else
         return null;
   }

   public R visit(NodeOptional n, A argu) {
      if ( n.present() )
         return n.node.accept(this,argu);
      else
         return null;
   }

   public R visit(NodeSequence n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeToken n, A argu) { return (R)n.tokenImage; }

   class ProcedureProperties
   {
      public int argCount;
      public int localVarCount;
      public int tempCount;
      public int maxArgCount;
   }

   class BasicBlock
   {
      public HashSet<Integer> def;
      public HashSet<Integer> use;
      public HashSet<Integer> in;
      public HashSet<Integer> out;
      public String type;
      public int next;
      public String label;
      public int labelNext;
      public String scope;
      public int lineNumber;

      public BasicBlock()
      {
         def = new HashSet<Integer>();
         use = new HashSet<Integer>();
         in = new HashSet<Integer>();
         out = new HashSet<Integer>();
      }
   }

   class SimpleExpReturn
   {
      public int type;
      public int temp;
      public int number;
      public String label;
   }

   class ExpReturn
   {
      public HashSet<Integer> use;
      public String type;

      public ExpReturn()
      {
         use = new HashSet<Integer>();
      }
   }

   class ScopeArgument
   {
      public String scope;
      public boolean isLabel;
      public boolean labelPresent;
   }

   class Interval
   {
      public int start;
      public int end;
      public int temp;

      public Interval(int start, int end, int key)
      {
         this.start = start;
         this.end = end;
         this.temp = key;
      }
   }

   // Global variables
   HashMap<String, ProcedureProperties> procProps = new HashMap<String, ProcedureProperties>();
   TreeMap<Integer, BasicBlock> instructions = new TreeMap<Integer, BasicBlock>();
   TreeMap<String, Integer> labelMap = new TreeMap<String, Integer>();
   HashMap<Integer, ExpReturn> expMap = new HashMap<Integer, ExpReturn>();
   LinkedHashMap<String, TreeMap<Integer, BasicBlock>> sortedInstrs = new LinkedHashMap<String, TreeMap<Integer, BasicBlock>>();
   TreeMap<String, TreeMap<Integer, Interval>> intervals = new TreeMap<String, TreeMap<Integer, Interval>>();
   int stage = 1;
   int expCount = 0;
   boolean debug = false;
   public int nextExp() {return expCount++;}
   HashMap<String, HashMap<Integer, String>> registerAllocation = new HashMap<String, HashMap<Integer, String>>();
   Stack<String> availableRegisters = new Stack<String>();
   HashMap<String, HashMap<Integer, Integer>> spillNumberMap = new HashMap<String, HashMap<Integer, Integer>>();

   int globalSpillNumber = 0;
   public int nextSpillNumber() {return globalSpillNumber++;}

   PriorityQueue<Interval> active = new PriorityQueue<Interval>(new Comparator<Interval>() {
      //Sorted by increasing order of end
      @Override
      public int compare(Interval i1, Interval i2) {
         return i1.end - i2.end;
      }
   });
   PriorityQueue<Interval> liveIntervals = new PriorityQueue<Interval>(new Comparator<Interval>() {
      //Sorted by increasing order of start
      @Override
      public int compare(Interval i1, Interval i2) {
         return i1.start - i2.start;
      }
   });
   PriorityQueue<Interval> reverseActive = new PriorityQueue<Interval>(new Comparator<Interval>() {
      //Sorted by decreasing order of start
      @Override
      public int compare(Interval i1, Interval i2) {
         return i2.end - i1.end;
      }
   });

   // Custom functions

   public void fillInOut()
   {
      // Fill in the in and out sets for each basic block using def and use sets
      // and the in and out sets of the previous basic block
      boolean changed = true;
      while(changed)
      {
         changed = false;
         for(Map.Entry<Integer, BasicBlock> entry : instructions.entrySet())
         {
            BasicBlock bb = entry.getValue();
            HashSet<Integer> oldIn = new HashSet<Integer>(bb.in);
            HashSet<Integer> oldOut = new HashSet<Integer>(bb.out);
            bb.in.clear();
            bb.in.addAll(bb.use);
            HashSet<Integer> outMinusDef = new HashSet<Integer>(bb.out);
            outMinusDef.removeAll(bb.def);
            bb.in.addAll(outMinusDef);
            bb.out.clear();

            if(bb.type.equals("JUMP")) 
            {
               if(labelMap.containsKey(bb.label)) 
               {
                  int labelNumber = labelMap.get(bb.label);
                  if(instructions.containsKey(labelNumber)) bb.out.addAll(instructions.get(labelNumber).in);
               }
            }
            else if(bb.type.equals("CJUMP"))
            {
               if(instructions.containsKey(bb.next)) bb.out.addAll(instructions.get(bb.next).in);
               if(labelMap.containsKey(bb.label)) 
               {
                  int labelNumber = labelMap.get(bb.label);
                  if(instructions.containsKey(labelNumber)) bb.out.addAll(instructions.get(labelNumber).in);
               }
            }
            else if(instructions.containsKey(bb.next)) bb.out.addAll(instructions.get(bb.next).in);
            
            if(!oldIn.equals(bb.in) || !oldOut.equals(bb.out)) changed = true;
         }
      }
   }

   public void sortByScope()
   {
      for(Map.Entry<Integer, BasicBlock> entry : instructions.entrySet())
      {
         BasicBlock bb = entry.getValue();
         if(!sortedInstrs.containsKey(bb.scope)) sortedInstrs.put(bb.scope, new TreeMap<Integer, BasicBlock>());
         sortedInstrs.get(bb.scope).put(entry.getKey(), bb);
      }
   }

   public void findIntervalsByScope()
   {
      // start of each interval is the first occurance in the out set
      // end of each interval is the last occurance in the in set
      for(Map.Entry<String, TreeMap<Integer, BasicBlock>> entry : sortedInstrs.entrySet())
      {
         String scope = entry.getKey();
         TreeMap<Integer, BasicBlock> instrs = entry.getValue();
         intervals.put(scope, new TreeMap<Integer, Interval>());
         for(Map.Entry<Integer, BasicBlock> bbEntry : instrs.entrySet())
         {
            BasicBlock bb = bbEntry.getValue();
            for(Integer temp : bb.out)
            {
               if(!intervals.get(scope).containsKey(temp)) intervals.get(scope).put(temp, new Interval(bbEntry.getKey(), bbEntry.getKey(), temp));
               else
               {
                  Interval interval = intervals.get(scope).get(temp);
                  interval.end = bbEntry.getKey();
               }
            }
            for(Integer temp : bb.in)
            {
               if(!intervals.get(scope).containsKey(temp)) intervals.get(scope).put(temp, new Interval(bbEntry.getKey(), bbEntry.getKey(), temp));
               else
               {
                  Interval interval = intervals.get(scope).get(temp);
                  interval.end = bbEntry.getKey();
               }
            }
         }
      }
   }

   public void printBasicBlocks()
   {
      Iterator<String> itr = sortedInstrs.keySet().iterator();
      while(itr.hasNext()){
         String key = itr.next();
         System.out.println("Scope: " + key);
         Iterator<Integer> itr2 = sortedInstrs.get(key).keySet().iterator();
         while(itr2.hasNext()){
            Integer key2 = itr2.next();
            BasicBlock bb = sortedInstrs.get(key).get(key2);
            System.out.println("\tBasic Block: " + key2);
            System.out.println("\t\tType: " + bb.type);
            System.out.println("\t\tLabel: " + bb.label);
            System.out.println("\t\tNext: " + bb.next);
            System.out.println("\t\tUse: " + bb.use);
            System.out.println("\t\tDef: " + bb.def);
            System.out.println("\t\tIn: " + bb.in);
            System.out.println("\t\tOut: " + bb.out);
            System.out.println();
         }
      }
   }

   public void printLabels()
   {
      //print labels
      System.out.println("Labels:");
      Iterator<String> itr3 = labelMap.keySet().iterator();
      while(itr3.hasNext()){
         String key = itr3.next();
         System.out.println("\t" + key + ": " + labelMap.get(key));
      }
   }

   public void printIntervals()
   {
      //print intervals
      Iterator<String> itr4 = intervals.keySet().iterator();
      while(itr4.hasNext()){
         String key = itr4.next();
         System.out.println("Scope: " + key);
         Iterator<Integer> itr5 = intervals.get(key).keySet().iterator();
         while(itr5.hasNext()){
            Integer key2 = itr5.next();
            Interval interval = intervals.get(key).get(key2);
            System.out.println("\tTemp: " + key2);
            System.out.println("\t\tStart: " + interval.start);
            System.out.println("\t\tEnd: " + interval.end);
            System.out.println();
         }
      }
   }

   public void populateRegisters()
   {
      availableRegisters.clear();
      for(int i = 9; i >= 0; i--) availableRegisters.push("t" + i);
      for(int i = 7; i >= 0; i--) availableRegisters.push("s" + i);
   }

   // Linear Search Algorithm
   public void expireOldIntervals(int start, String scope)
   {
      while(!active.isEmpty() && active.peek().end < start)
      {
         Interval interval = active.poll();
         availableRegisters.push(registerAllocation.get(scope).get(interval.temp));
      }
   }

   public void spillAtInterval(Interval interval, String scope)
   {
      Interval spill = reverseActive.peek();
      if(spill != null && spill.end > interval.end)
      {
         registerAllocation.get(scope).put(interval.temp, registerAllocation.get(scope).get(spill.temp));
         registerAllocation.get(scope).put(spill.temp, "spill");
         reverseActive.poll();
         active.remove(interval);
         reverseActive.add(interval);
         active.add(interval);
      }
      else
      {
         registerAllocation.get(scope).put(interval.temp, "spill");
      }
   }

   public void linearScanAlgorithm(String scopeLabel)
   {  //add in register allocation for the particular label scope
      // total available registers - 18 s0-s7, t0-t9
      
      active.clear();
      liveIntervals.clear();
      reverseActive.clear();
      for(Map.Entry<Integer, Interval> entry : intervals.get(scopeLabel).entrySet())
      {
         liveIntervals.add(entry.getValue());
      }
      int arguments;
      if(!scopeLabel.equals("MAIN")) arguments = procProps.get(scopeLabel).argCount;
      else arguments = 0;

      HashMap<Integer, String> tempToReg = new HashMap<Integer, String>();
      registerAllocation.put(scopeLabel, tempToReg);

      for(int i=0; i<arguments; i++)
      {
         Interval interval = intervals.get(scopeLabel).get(i);
         if(interval != null)
         {
            String registerAlloc;

            if(i<=3) registerAlloc = "a" + i;
            else registerAlloc = "paraspill";

            tempToReg.put(i, registerAlloc);
            liveIntervals.remove(interval);
         }
      }

      while(!liveIntervals.isEmpty())
      {
         expireOldIntervals(liveIntervals.peek().start, scopeLabel);
         if(!availableRegisters.isEmpty())
         {
            Interval interval = liveIntervals.poll();
            String registerAlloc = availableRegisters.pop();
            tempToReg.put(interval.temp, registerAlloc);
            active.add(interval);
            reverseActive.add(interval);
         }
         else
         {
            spillAtInterval(liveIntervals.poll(), scopeLabel);
         }
      }
   }

   public void registerAllocate()
   {
      Iterator<String> itr = intervals.keySet().iterator();
      while(itr.hasNext()){
         String key = itr.next();
         populateRegisters();
         linearScanAlgorithm(key);
      }
   }

   public void printRegisterAllocation()
   {
      Iterator<String> itr = registerAllocation.keySet().iterator();
      while(itr.hasNext()){
         String key = itr.next();
         System.out.println("Scope: " + key);
         Iterator<Integer> itr2 = registerAllocation.get(key).keySet().iterator();
         while(itr2.hasNext()){
            Integer key2 = itr2.next();
            System.out.print("\tTemp: " + key2);
            System.out.println(" Register: " + registerAllocation.get(key).get(key2));
            System.out.println();
         }
      }
   }

   public int findSpills(String scope)
   {
      int spillCount = 0;
      Iterator<Integer> itr = registerAllocation.get(scope).keySet().iterator();
      while(itr.hasNext()){
         Integer key = itr.next();
         if(registerAllocation.get(scope).get(key).equals("spill")) spillCount++;
      }
      return spillCount;
   }

   public void allocateSpillNumbers(String scope)
   {
      Iterator<Integer> itr = registerAllocation.get(scope).keySet().iterator();
      HashMap<Integer, Integer> tempToSpill = spillNumberMap.get(scope);
      while(itr.hasNext()){
         Integer key = itr.next();
         if(registerAllocation.get(scope).get(key).equals("spill"))
         {
            int temp = key;
            int spillnum = nextSpillNumber();
            tempToSpill.put(temp, spillnum);
         }
      }
   }

   //
   // User-generated visitor methods below
   //

   /**
    * f0 -> "MAIN"
    * f1 -> StmtList()
    * f2 -> "END"
    * f3 -> ( Procedure() )*
    * f4 -> <EOF>
    */
   public R visit(Goal n, A argu) 
   {
      ScopeArgument scope = new ScopeArgument();
      scope.scope = "MAIN";
      scope.isLabel = true;
      n.f1.accept(this, (A)scope);
      n.f3.accept(this, argu);

      fillInOut();
      sortByScope();
      findIntervalsByScope();
      registerAllocate();
      if(debug)
      {
         printRegisterAllocation();
         printBasicBlocks();
         printIntervals();
         printLabels();
      }

      stage = 2;

      System.out.println("MAIN");
      globalSpillNumber = 0;
      n.f1.accept(this, (A)scope);
      System.out.println("END");
      n.f3.accept(this, argu);

      return null;
   }

   /**
    * f0 -> Label()
    * f1 -> "["
    * f2 -> IntegerLiteral()
    * f3 -> "]"
    * f4 -> StmtExp()
    */
   public R visit(Procedure n, A argu) 
   {
      ScopeArgument scope = new ScopeArgument();
      scope.isLabel = false;
      String label = n.f0.accept(this, (A)scope).toString();
      scope.scope = label;

      ProcedureProperties procedure;
      if(stage == 1)
      {
         int arguments = Integer.parseInt(n.f2.accept(this, argu).toString());

         procedure = new ProcedureProperties();
         procedure.argCount = arguments;
         procedure.maxArgCount = arguments;
         procProps.put(label, procedure);
      }
      else if(stage == 2)
      {
         procedure = procProps.get(label);
         int args = procedure.argCount;
         int mac = procedure.maxArgCount;
         int ss = 0;
         if(mac > 4) ss = mac - 4;
         ss += findSpills(label);
         if (mac > 0) ss += 18;
         else ss += 8;
         System.out.println(label + " [" + args + "]" + " [" + ss + "]" + " [" + mac + "]");

         spillNumberMap.put(label, new HashMap<Integer, Integer>());
         globalSpillNumber = 0;

         for(int i=4; i<args; i++) spillNumberMap.get(label).put(i, nextSpillNumber());

         for(int i=0; i<8; i++) System.out.println("ASTORE SPILLEDARG " + nextSpillNumber() + " s" + i);

         allocateSpillNumbers(label);
      }
      n.f4.accept(this, (A)scope);

      return null;
   }

   /**
    * f0 -> "BEGIN"
    * f1 -> StmtList()
    * f2 -> "RETURN"
    * f3 -> SimpleExp()
    * f4 -> "END"
    */
    public R visit(StmtExp n, A argu) 
    {
      ScopeArgument scope = (ScopeArgument)argu;
      if(stage == 2)
      {
         System.out.println("BEGIN");
      }
      n.f1.accept(this, argu);

      SimpleExpReturn simpleExpReturn = (SimpleExpReturn)n.f3.accept(this, argu);

      if(stage == 1)
      {
         BasicBlock newBlock = new BasicBlock();
         newBlock.type = "RETURN";
         if(simpleExpReturn.type == 0) newBlock.use.add(simpleExpReturn.temp);
         newBlock.scope = ((ScopeArgument)argu).scope;

         int lineNumber = n.f2.beginLine;
         newBlock.next = lineNumber + 1;

         if(scope.labelPresent)
         {
            lineNumber--;
            scope.labelPresent = false;
         }
         newBlock.lineNumber = lineNumber;
         instructions.put(lineNumber, newBlock);
      }
      else if(stage == 2)
      {
         HashMap<Integer, String> tempToReg = registerAllocation.get(((ScopeArgument)argu).scope);
      
         if(simpleExpReturn.type == 0)
         {
            String reg = tempToReg.get(simpleExpReturn.temp);
            if(reg.equals("spill") || reg.equals("paraspill"))
            {
               int spillnum = spillNumberMap.get(scope.scope).get(simpleExpReturn.temp);
               System.out.println("ALOAD v1 SPILLEDARG " + spillnum);
               System.out.println("MOVE v0 v1");
            }
            else
            {
               System.out.println("MOVE v0 " + reg);
            }
         }
         else if(simpleExpReturn.type == 1)
         {
            System.out.println("MOVE v1 " + simpleExpReturn.number);
            System.out.println("MOVE v0 v1");
         }
         System.out.println("END");
      }
      return null;
   }

   /**
    * f0 -> ( ( Label() )? Stmt() )*
    */
   public R visit(StmtList n, A argu) {
      R _ret=null;
      Vector<Node> v = n.f0.nodes;
      for(int i = 0; i < v.size(); i++) {
         ScopeArgument scope = (ScopeArgument)argu;
         scope.isLabel = true;
         v.elementAt(i).accept(this, (A)scope);
      }
      
      // n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> NoOpStmt()
    *       | ErrorStmt()
    *       | CJumpStmt()
    *       | JumpStmt()
    *       | HStoreStmt()
    *       | HLoadStmt()
    *       | MoveStmt()
    *       | PrintStmt()
    */
   public R visit(Stmt n, A argu) {
      R _ret=null;
      ((ScopeArgument)argu).isLabel = false;
      n.f0.accept(this, argu);
      ((ScopeArgument)argu).isLabel = true;      
      return _ret;
   }

   /**
    * f0 -> "NOOP"
    */
   public R visit(NoOpStmt n, A argu) {
      if(stage == 1)
      {
         BasicBlock newBlock = new BasicBlock();
         newBlock.type = "NOOP";
         newBlock.scope = ((ScopeArgument)argu).scope;

         int lineNumber = n.f0.beginLine;
         newBlock.next = lineNumber + 1;

         ScopeArgument scope = (ScopeArgument)argu;
         if(scope.labelPresent)
         {
            lineNumber--;
            scope.labelPresent = false;
         }
         newBlock.lineNumber = lineNumber;
         instructions.put(lineNumber, newBlock);
      }
      else if (stage == 2)
      {
         System.out.println("NOOP");
      }
      return null;
   }

   /**
    * f0 -> "ERROR"
    */
   public R visit(ErrorStmt n, A argu) {
      if(stage == 1)
      {
         BasicBlock newBlock = new BasicBlock();
         newBlock.type = "ERROR";
         newBlock.scope = ((ScopeArgument)argu).scope;

         int lineNumber = n.f0.beginLine;
         newBlock.next = lineNumber + 1;

         ScopeArgument scope = (ScopeArgument)argu;
         if(scope.labelPresent)
         {
            lineNumber--;
            scope.labelPresent = false;
         }

         newBlock.lineNumber = lineNumber;
         instructions.put(lineNumber, newBlock);
      }
      else if(stage == 2)
      {
         System.out.println("ERROR");
      }
      return null;
   }

   /**
    * f0 -> "CJUMP"
    * f1 -> Temp()
    * f2 -> Label()
    */
   public R visit(CJumpStmt n, A argu) 
   {
      int temp = Integer.parseInt(n.f1.accept(this, argu).toString());
      String label = n.f2.accept(this, argu).toString();

      if(stage == 1)
      {
         BasicBlock newBlock = new BasicBlock();
         newBlock.type = "CJUMP";
         newBlock.use.add(temp);
         newBlock.label = label;
         newBlock.scope = ((ScopeArgument)argu).scope;

         int lineNumber = n.f0.beginLine;
         newBlock.next = lineNumber + 1;
         ScopeArgument scope = (ScopeArgument)argu;
         if(scope.labelPresent)
         {
            lineNumber--;
            scope.labelPresent = false;
         }

         newBlock.lineNumber = lineNumber;
         instructions.
         put(lineNumber, newBlock);
      }
      else if(stage == 2)
      {
         HashMap<Integer, String> tempToReg = registerAllocation.get(((ScopeArgument)argu).scope);
         String reg = tempToReg.get(temp);
         if(reg.equals("spill") || reg.equals("paraspill"))
         {
            int spillnum = spillNumberMap.get(((ScopeArgument)argu).scope).get(temp);
            System.out.println("ALOAD v1 SPILLEDARG " + spillnum);
            System.out.println("CJUMP v1 " + label);
         }
         else
         {
            System.out.println("CJUMP " + reg + " " + label);
         }
      }
      return null;
   }

   /**
    * f0 -> "JUMP"
    * f1 -> Label()
    */
   public R visit(JumpStmt n, A argu) 
   {
      String label = n.f1.accept(this, argu).toString();

      if(stage == 1)
      {
         BasicBlock newBlock = new BasicBlock();
         newBlock.type = "JUMP";
         newBlock.label = label;
         newBlock.scope = ((ScopeArgument)argu).scope;

         int lineNumber = n.f0.beginLine;
         newBlock.next = lineNumber + 1;
         ScopeArgument scope = (ScopeArgument)argu;
         if(scope.labelPresent)
         {
            lineNumber--;
            scope.labelPresent = false;
         }

         newBlock.lineNumber = lineNumber;
         instructions.put(lineNumber, newBlock);
      }
      else if(stage == 2)
      {
         System.out.println("JUMP " + label);
      }
      return null;
   }

   /**
    * f0 -> "HSTORE"
    * f1 -> Temp()
    * f2 -> IntegerLiteral()
    * f3 -> Temp()
    */
   public R visit(HStoreStmt n, A argu) 
   {
      int temp1 = Integer.parseInt(n.f1.accept(this, argu).toString());
      int temp2 = Integer.parseInt(n.f3.accept(this, argu).toString());
      int offset = Integer.parseInt(n.f2.accept(this, argu).toString());

      if(stage == 1)
      {
         BasicBlock newBlock = new BasicBlock();
         newBlock.type = "HSTORE";
         newBlock.use.add(temp1);
         newBlock.use.add(temp2);
         newBlock.scope = ((ScopeArgument)argu).scope;

         int lineNumber = n.f0.beginLine;
         newBlock.next = lineNumber + 1;
         ScopeArgument scope = (ScopeArgument)argu;
         if(scope.labelPresent)
         {
            lineNumber--;
            scope.labelPresent = false;
         }

         newBlock.lineNumber = lineNumber;
         instructions.put(lineNumber, newBlock);
      }
      else if (stage == 2)
      {
         HashMap<Integer, String> tempToReg = registerAllocation.get(((ScopeArgument)argu).scope);
         String reg1 = tempToReg.get(temp1);
         String reg2 = tempToReg.get(temp2);
         if(reg1.equals("spill") || reg1.equals("paraspill"))
         {
            int spillnum = spillNumberMap.get(((ScopeArgument)argu).scope).get(temp1);
            System.out.println("ALOAD v0 SPILLEDARG " + spillnum);
            reg1 = "v0";
         }
         if(reg2.equals("spill") || reg2.equals("paraspill"))
         {
            int spillnum = spillNumberMap.get(((ScopeArgument)argu).scope).get(temp2);
            System.out.println("ALOAD v1 SPILLEDARG " + spillnum);
            reg2 = "v1";
         }
         System.out.println("HSTORE " + reg1 + " " + offset + " " + reg2);
      }
      return null;
   }

   /**
    * f0 -> "HLOAD"
    * f1 -> Temp()
    * f2 -> Temp()
    * f3 -> IntegerLiteral()
    */
   public R visit(HLoadStmt n, A argu) 
   {
      int temp1 = Integer.parseInt(n.f1.accept(this, argu).toString());
      int temp2 = Integer.parseInt(n.f2.accept(this, argu).toString());
      int offset = Integer.parseInt(n.f3.accept(this, argu).toString());

      if(stage == 1)
      {
         BasicBlock newBlock = new BasicBlock();
         newBlock.type = "HLOAD";
         newBlock.use.add(temp2);
         newBlock.def.add(temp1);
         newBlock.scope = ((ScopeArgument)argu).scope;

         int lineNumber = n.f0.beginLine;
         newBlock.next = lineNumber + 1;
         ScopeArgument scope = (ScopeArgument)argu;
         if(scope.labelPresent)
         {
            lineNumber--;
            scope.labelPresent = false;
         }

         newBlock.lineNumber = lineNumber;
         instructions.put(lineNumber, newBlock);
      }
      else if(stage == 2)
      {
         HashMap<Integer, String> tempToReg = registerAllocation.get(((ScopeArgument)argu).scope);
         String reg1 = tempToReg.get(temp1);
         String reg2 = tempToReg.get(temp2);
         if(reg2.equals("spill") || reg2.equals("paraspill"))
         {
            int spillnum = spillNumberMap.get(((ScopeArgument)argu).scope).get(temp2);
            System.out.println("ALOAD v1 SPILLEDARG " + spillnum);
            reg2 = "v1";
         }
         if(reg1.equals("spill") || reg1.equals("paraspill"))
         {
            int spillnum = spillNumberMap.get(((ScopeArgument)argu).scope).get(temp1);
            System.out.println("HLOAD v0 " + reg2 + " " + offset);
            System.out.println("ASTORE SPILLEDARG " + spillnum + " v0");
         }
         else
         {
            System.out.println("HLOAD " + reg1 + " " + reg2 + " " + offset);
         }
      }
      return null;
   }

   /**
    * f0 -> "MOVE"
    * f1 -> Temp()
    * f2 -> Exp()
    */
   public R visit(MoveStmt n, A argu) 
   {
      int temp = Integer.parseInt(n.f1.accept(this, argu).toString());
      int expNumber = Integer.parseInt(n.f2.accept(this, argu).toString());
      ExpReturn expReturn = expMap.get(expNumber);

      if(stage == 1)
      {
         BasicBlock newBlock = new BasicBlock();
         newBlock.type = "MOVE";
         newBlock.use.addAll(expReturn.use);
         newBlock.def.add(temp);
         newBlock.scope = ((ScopeArgument)argu).scope;

         int lineNumber = n.f0.beginLine;
         newBlock.next = lineNumber + 1;
         ScopeArgument scope = (ScopeArgument)argu;
         if(scope.labelPresent)
         {
            lineNumber--;
            scope.labelPresent = false;
         }

         newBlock.lineNumber = lineNumber;
         instructions.put(lineNumber, newBlock);
      }
      else if (stage == 2)
      {
         
      }
      return null;
   }

   /**
    * f0 -> "PRINT"
    * f1 -> SimpleExp()
    */
   public R visit(PrintStmt n, A argu) 
   {
      SimpleExpReturn simpleExpReturn = (SimpleExpReturn)n.f1.accept(this, argu);

      if(stage == 1)
      {
         BasicBlock newBlock = new BasicBlock();
         newBlock.type = "PRINT";
         if(simpleExpReturn.type == 0) newBlock.use.add(simpleExpReturn.temp);
         newBlock.scope = ((ScopeArgument)argu).scope;

         int lineNumber = n.f0.beginLine;
         newBlock.next = lineNumber + 1;
         ScopeArgument scope = (ScopeArgument)argu;
         if(scope.labelPresent)
         {
            lineNumber--;
            scope.labelPresent = false;
         }

         newBlock.lineNumber = lineNumber;
         instructions.put(lineNumber, newBlock);
      }
      else if(stage == 2)
      {
         HashMap<Integer, String> tempToReg = registerAllocation.get(((ScopeArgument)argu).scope);
         if(simpleExpReturn.type == 0)
         {
            String reg = tempToReg.get(simpleExpReturn.temp);
            if(reg.equals("spill") || reg.equals("paraspill"))
            {
               int spillnum = spillNumberMap.get(((ScopeArgument)argu).scope).get(simpleExpReturn.temp);
               System.out.println("ALOAD v0 SPILLEDARG " + spillnum);
            }
            System.out.println("PRINT v0");
         }
         else
         {
            System.out.println("MOVE v0 " + simpleExpReturn.number);
            System.out.println("PRINT v0");
         }
      }
      return null;
   }

   /**
    * f0 -> Call()
    *       | HAllocate()
    *       | BinOp()
    *       | SimpleExp()
    */
   public R visit(Exp n, A argu) 
   {
      SimpleExpReturn simpleExpReturn;
      ExpReturn expReturn;
      if(n.f0.which == 3)
      {
         simpleExpReturn = (SimpleExpReturn)n.f0.accept(this, argu);
         expReturn = new ExpReturn();
         if(simpleExpReturn.type == 0) expReturn.use.add(simpleExpReturn.temp);
      }
      else
      {
         int expNumber = Integer.parseInt(n.f0.accept(this, argu).toString());
         expReturn = expMap.get(expNumber);
         expMap.remove(expNumber);
      }

      expReturn.type = "EXP";
      int expNumber = nextExp();
      expMap.put(expNumber, expReturn);

      return (R)(Integer.toString(expNumber));
   }

   /**
    * f0 -> "CALL"
    * f1 -> SimpleExp()
    * f2 -> "("
    * f3 -> ( Temp() )*
    * f4 -> ")"
    */
   public R visit(Call n, A argu) 
   {
      SimpleExpReturn simpleExpReturn = (SimpleExpReturn)n.f1.accept(this, argu);

      ExpReturn expReturn = new ExpReturn();
      if(simpleExpReturn.type == 0) expReturn.use.add(simpleExpReturn.temp);
      expReturn.type = "CALL";

      Vector<Node> nodes = n.f3.nodes;
      for(int i = 0; i < nodes.size(); i++) 
         expReturn.use.add(Integer.parseInt(nodes.get(i).accept(this, argu).toString()));

      int tempArgCount = nodes.size();
      if(procProps.containsKey(((ScopeArgument)argu).scope))
         if(procProps.get(((ScopeArgument)argu).scope).maxArgCount < tempArgCount)
            procProps.get(((ScopeArgument)argu).scope).maxArgCount = tempArgCount;

      int expNumber = nextExp();
      expMap.put(expNumber, expReturn);

      return (R)(Integer.toString(expNumber));
   }

   /**
    * f0 -> "HALLOCATE"
    * f1 -> SimpleExp()
    */
   public R visit(HAllocate n, A argu) 
   {  
      SimpleExpReturn simpleExpReturn = (SimpleExpReturn)n.f1.accept(this, argu);

      ExpReturn expReturn = new ExpReturn();
      if(simpleExpReturn.type == 0) expReturn.use.add(simpleExpReturn.temp);
      expReturn.type = "HALLOCATE";

      int expNumber = nextExp();
      expMap.put(expNumber, expReturn);

      return (R)(Integer.toString(expNumber));
   }

   /**
    * f0 -> Operator()
    * f1 -> Temp()
    * f2 -> SimpleExp()
    */
   public R visit(BinOp n, A argu) 
   {
      String op = n.f0.accept(this, argu).toString();
      Integer temp = Integer.parseInt(n.f1.accept(this, argu).toString());
      SimpleExpReturn simpleExpReturn = (SimpleExpReturn)n.f2.accept(this, argu);

      ExpReturn expReturn = new ExpReturn();
      expReturn.use.add(temp);
      if(simpleExpReturn.type == 0) expReturn.use.add(simpleExpReturn.temp);
      expReturn.type = "BINOP";

      int expNumber = nextExp();
      expMap.put(expNumber, expReturn);

      return (R)(Integer.toString(expNumber));
   }

   /**
    * f0 -> "LE"
    *       | "NE"
    *       | "PLUS"
    *       | "MINUS"
    *       | "TIMES"
    *       | "DIV"
    */
   public R visit(Operator n, A argu) {
      return n.f0.accept(this, argu);
   }

   /**
    * f0 -> Temp()
    *       | IntegerLiteral()
    *       | Label()
    */
   public R visit(SimpleExp n, A argu) 
   {
      R ret = n.f0.accept(this, argu);

      SimpleExpReturn simpleExpReturn = new SimpleExpReturn();
      simpleExpReturn.type = n.f0.which;

      if(n.f0.which == 0) simpleExpReturn.temp = Integer.parseInt(ret.toString());
      else if(n.f0.which == 1) simpleExpReturn.number = Integer.parseInt(ret.toString());
      else if(n.f0.which == 2) simpleExpReturn.label = ret.toString();

      return (R)simpleExpReturn;
   }

   /**
    * f0 -> "TEMP"
    * f1 -> IntegerLiteral()
    */
   public R visit(Temp n, A argu) {
      return n.f1.accept(this, argu);
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   public R visit(IntegerLiteral n, A argu) {
      return n.f0.accept(this, argu);
   }

   /**
    * f0 -> <IDENTIFIER>
    */
   public R visit(Label n, A argu) 
   {
      R label = n.f0.accept(this, argu);
      int lineNumber = n.f0.beginLine;
      if(((ScopeArgument)argu).isLabel){
         labelMap.put(label.toString(), lineNumber);
         ((ScopeArgument)argu).labelPresent = true;

         if(stage == 2) System.out.println(label.toString());
      }
      return label;
   }
}
